name: Publish

on:
  workflow_dispatch:
    inputs:
      publishToNuGet:
        description: "Publish to NuGet.org (PowerShell Gallery uses same feed)"
        required: false
        default: "true"
      publishToGitHub:
        description: "Publish to GitHub Packages"
        required: false
        default: "true"
      versionOverride:
        description: "Override module version (optional)"
        required: false
        default: ""
      createRelease:
        description: "Create GitHub Release"
        required: false
        default: "true"
  release:
    types: [published]
  workflow_call:
    secrets:
      PSGALLERYAPIKEY:
        required: false
      NUGETAPIKEY:
        required: false
      PACKAGES_TOKEN:
        required: false
  workflow_run:
    workflows: ["Tests"]
    types:
      - completed
    branches:
      - main

permissions:
  contents: write

jobs:
  validate-and-publish:
    name: Validate and Publish
    runs-on: windows-latest
    env:
      PSGALLERYAPIKEY: ${{ secrets.PSGALLERYAPIKEY }}
      NUGETAPIKEY: ${{ secrets.NUGETAPIKEY }}
      PACKAGES_TOKEN: ${{ secrets.PACKAGES_TOKEN }}
      PUBLISH_TO_NUGET_INPUT: ${{ github.event.inputs.publishToNuGet }}
      PUBLISH_TO_GITHUB_INPUT: ${{ github.event.inputs.publishToGitHub }}
      CREATE_RELEASE_INPUT: ${{ github.event.inputs.createRelease }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Install quality tools
        run: |
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
          if (-not (Get-Module -ListAvailable -Name Pester)) {
              Install-Module -Name Pester -MinimumVersion 5.4.0 -Force -SkipPublisherCheck
          }
          if (-not (Get-Module -ListAvailable -Name PSScriptAnalyzer)) {
              Install-Module -Name PSScriptAnalyzer -Force -SkipPublisherCheck
          }
        shell: pwsh

      - name: Build latest Manifest Version
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Starting build process..." -ForegroundColor Cyan

          # Verify build script exists
          if (-not (Test-Path ".\build.ps1")) {
              throw "Build script not found: .\build.ps1"
          }

          # Verify module directory exists
          if (-not (Test-Path ".\ColorScripts-Enhanced")) {
              throw "Module directory not found: .\ColorScripts-Enhanced"
          }

          # Run build script with error handling
          try {
              Write-Host "Executing build script..." -ForegroundColor Yellow
              & .\build.ps1

              if ($LASTEXITCODE -and $LASTEXITCODE -ne 0) {
                  throw "Build script failed with exit code: $LASTEXITCODE"
              }

              Write-Host "Build completed successfully!" -ForegroundColor Green
          }
          catch {
              Write-Host "Build failed: $_" -ForegroundColor Red
              throw
          }

          # Verify manifest was updated
          $manifestPath = ".\ColorScripts-Enhanced\ColorScripts-Enhanced.psd1"
          if (-not (Test-Path $manifestPath)) {
              throw "Module manifest not found after build: $manifestPath"
          }

          # Test manifest is valid
          try {
              $manifest = Test-ModuleManifest -Path $manifestPath -ErrorAction Stop
              Write-Host "Manifest validation successful. Version: $($manifest.Version)" -ForegroundColor Green
          }
          catch {
              Write-Host "Manifest validation failed: $_" -ForegroundColor Red
              throw
          }
        shell: pwsh

      - name: Run Script Analyzer
        run: |
          Import-Module PSScriptAnalyzer
          $settingsPath = Join-Path (Get-Location) 'PSScriptAnalyzerSettings.psd1'
          $moduleRoot = Join-Path (Get-Location) 'ColorScripts-Enhanced'
          $moduleFiles = Get-ChildItem -Path $moduleRoot -File -Recurse -Include *.ps1, *.psm1, *.psd1

          $allFindings = New-Object 'System.Collections.Generic.List[psobject]'

          foreach ($file in $moduleFiles) {
            $parameters = @{
              Path        = $file.FullName
              Severity    = 'Error', 'Warning'
              ErrorAction = 'Stop'
            }

            if (Test-Path $settingsPath) {
              $parameters.Settings = $settingsPath
            }

            try {
              $diagnostics = Invoke-ScriptAnalyzer @parameters
            }
            catch {
              $exception = $_.Exception
              $isNullReference = $exception -is [System.NullReferenceException] -or ($exception -and $exception.Message -like 'Object reference*')

              if ($isNullReference -and $parameters.ContainsKey('Settings')) {
                Write-Warning "ScriptAnalyzer hit a known issue on '$($file.FullName)' with custom settings. Retrying without settings."
                $parameters.Remove('Settings')
                $diagnostics = Invoke-ScriptAnalyzer @parameters
              }
              else {
                throw
              }
            }

            if ($diagnostics) {
              foreach ($entry in $diagnostics) {
                $allFindings.Add($entry) | Out-Null
              }
            }
          }

          if ($allFindings.Count -gt 0) {
            $allFindings | Format-Table -AutoSize
            throw 'ScriptAnalyzer reported findings.'
          }
        shell: pwsh

      - name: Run Pester tests
        run: |
          Import-Module Pester
          $configuration = New-PesterConfiguration
          $configuration.Run.Path = './Tests'
          $configuration.Output.Verbosity = 'Detailed'
          Invoke-Pester -Configuration $configuration
        shell: pwsh

      - name: Verify manifest version
        id: manifest
        shell: pwsh
        run: |
          $manifest = Test-ModuleManifest -Path ./ColorScripts-Enhanced/ColorScripts-Enhanced.psd1
          $version = if ([string]::IsNullOrWhiteSpace('${{ github.event.inputs.versionOverride }}')) {
              $manifest.Version.ToString()
          } else {
              '${{ github.event.inputs.versionOverride }}'
          }

          Write-Host "Module version: $version"
          "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

          if ('${{ github.event_name }}' -eq 'release') {
              $tag = '${{ github.event.release.tag_name }}'.TrimStart('v')
              if ($tag -ne $version) {
                  throw "Release tag $tag does not match module version $version"
              }
          }

      - name: Create GitHub Release
        if: ${{ github.event_name != 'workflow_dispatch' || env.CREATE_RELEASE_INPUT != 'false' }}
        uses: ncipollo/release-action@2c591bcc8ecdcd2db72b97d6147f871fcd833ba5 # v1.14.0
        with:
          tag: v${{ steps.manifest.outputs.version }}
          name: Release v${{ steps.manifest.outputs.version }}
          draft: false
          prerelease: false
          generateReleaseNotes: true
          skipIfReleaseExists: true

      - name: Package module
        id: package
        run: |
          Import-Module PowerShellGet -ErrorAction Stop

          $stagingPath = Join-Path $env:RUNNER_TEMP "module-packages"
          if (Test-Path $stagingPath) {
              Remove-Item -Path $stagingPath -Recurse -Force
          }
          New-Item -ItemType Directory -Path $stagingPath | Out-Null

          $repoName = 'LocalModuleStaging'
          if (Get-PSRepository -Name $repoName -ErrorAction SilentlyContinue) {
              Unregister-PSRepository -Name $repoName -ErrorAction SilentlyContinue
          }

          Register-PSRepository -Name $repoName -SourceLocation $stagingPath -PublishLocation $stagingPath -InstallationPolicy Trusted

          $readmePath = Join-Path (Get-Location) 'ColorScripts-Enhanced/README.md'
          if (-not (Test-Path $readmePath)) {
              throw "README file not found at $readmePath"
          }

          try {
              Publish-Module -Path ./ColorScripts-Enhanced -Repository $repoName -NuGetApiKey 'LocalRepositoryKey' -ReadMe $readmePath -ErrorAction Stop | Out-Null
          }
          finally {
              Unregister-PSRepository -Name $repoName -ErrorAction SilentlyContinue
          }

          $package = Get-ChildItem -Path $stagingPath -Filter '*.nupkg' | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if (-not $package) {
              throw 'Failed to produce NuGet package for the module.'
          }

          "packagePath=$($package.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "packageName=$($package.Name)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          Write-Host "Packaged module to: $($package.FullName)"
        shell: pwsh

      - name: Normalize NuGet metadata
        run: pwsh -NoProfile -File ./scripts/Update-NuGetPackageMetadata.ps1 -PackagePath '${{ steps.package.outputs.packagePath }}'
        shell: pwsh

      - name: Publish to PowerShell Gallery
        run: |
          $packagePath = '${{ steps.package.outputs.packagePath }}'
          if (-not (Test-Path $packagePath)) {
              throw "Package not found at $packagePath"
          }

          $apiKey = $env:PSGALLERYAPIKEY
          if ([string]::IsNullOrWhiteSpace($apiKey)) {
              Write-Host 'No PowerShell Gallery API key provided. Skipping publish.'
              return
          }

          Write-Host "Publishing $packagePath to PowerShell Gallery"
          dotnet nuget push $packagePath --api-key $apiKey --source https://www.powershellgallery.com/api/v2/package --skip-duplicate
        shell: pwsh

      - name: Publish to NuGet.org
        if: ${{ env.NUGETAPIKEY != '' && (github.event_name != 'workflow_dispatch' || env.PUBLISH_TO_NUGET_INPUT != 'false') }}
        run: |
          $packagePath = '${{ steps.package.outputs.packagePath }}'
          if (-not (Test-Path $packagePath)) {
              throw "Package not found at $packagePath"
          }

          $apiKey = $env:NUGETAPIKEY
          if ([string]::IsNullOrWhiteSpace($apiKey)) {
              Write-Host 'No NuGet.org API key provided. Skipping publish.'
              return
          }

          Write-Host "Publishing $packagePath to NuGet.org"
          dotnet nuget push $packagePath --api-key $apiKey --source https://api.nuget.org/v3/index.json --skip-duplicate
        shell: pwsh

      - name: Publish to GitHub Packages
        if: ${{ env.PACKAGES_TOKEN != '' && (github.event_name != 'workflow_dispatch' || env.PUBLISH_TO_GITHUB_INPUT != 'false') }}
        run: |
          $packagePath = '${{ steps.package.outputs.packagePath }}'
          if (-not (Test-Path $packagePath)) {
              throw "Package not found at $packagePath"
          }

          $token = $env:PACKAGES_TOKEN
          if ([string]::IsNullOrWhiteSpace($token)) {
              Write-Host 'No GitHub Packages token provided. Skipping publish.'
              return
          }

          $source = "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json"
          Write-Host "Publishing $packagePath to GitHub Packages feed $source"
          dotnet nuget push $packagePath --api-key $token --source $source --skip-duplicate
        shell: pwsh
